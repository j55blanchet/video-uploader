{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/components/UploadScreen.vue?0758","webpack:///./src/components/WebcamBox.vue?0fbb","webpack:///./src/services/DataStore.ts","webpack:///./src/services/UrlInterpreter.ts","webpack:///./src/App.vue","webpack:///./src/components/UploadScreen.vue","webpack:///./src/services/WebcamProvider.ts","webpack:///./src/services/AzureUploader.ts","webpack:///./src/components/WebcamBox.vue","webpack:///./src/components/WebcamBox.vue?abcc","webpack:///./src/components/WebcamBox.vue?9016","webpack:///./src/components/UploadScreen.vue?cde5","webpack:///./src/components/UploadScreen.vue?dabe","webpack:///./src/App.vue?3acc","webpack:///./src/App.vue?eabf","webpack:///./src/registerServiceWorker.ts","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","dataStore","experimentName","prompt","participantId","participantIdWasSet","uploadName","uploadNameWasSet","InterpretUrl","urlParams","URLSearchParams","location","search","keys","forEach","class","type","disabled","state","isRecording","toggleRecording","webcamStatus","controls","src","recordedObjectUrl","isUploading","rerecord","uploadVideo","uploadError","recorder","mediaStream","activeConnections","Set","permissionState","isWebcamLoading","webcamError","this","readPermissionStatus","navigator","permissions","query","constraints","video","facingMode","width","height","aspectRatio","frameRate","audio","mediaDevices","getUserMedia","Error","videoE","add","console","log","srcObject","onloadedmetadata","play","delete","size","stopWebcam","stopRecording","getTracks","x","stop","rtc","startRecording","Promise","res","getBlob","defaultProvider","blobServiceClient","BlobServiceClient","blobName","client","getContainerClient","blockBlobClient","getBlockBlobClient","uploadData","ref","muted","webcamStartError","startWebcam","props","enableRecordButton","Boolean","default","setup","connectVideoElement","status","disconnectVideoElement","webcamProvider","methods","playVideo","render","components","WebcamBox","lastRecordedBlob","URL","createObjectURL","upload","error","UploadScreen","ready","registered","cached","updatefound","updated","offline","App","component","mount"],"mappings":"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","file":"js/app.4e141dbf.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([1,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./UploadScreen.vue?vue&type=style&index=0&id=4c9ab232&lang=scss\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./WebcamBox.vue?vue&type=style&index=0&id=b88bad26&lang=scss\"","import { reactive } from 'vue';\n\nconst dataStore = reactive({\n  experimentName: 'Unknown Experiment',\n  prompt: 'Use this page to record and upload your video',\n  participantId: '',\n  participantIdWasSet: false,\n  uploadName: '',\n  uploadNameWasSet: false,\n});\n\nexport default dataStore;\n","import dataStore from './DataStore';\n\nexport default function InterpretUrl(): void {\n\n  const urlParams = new URLSearchParams(window.location.search);\n\n  Object.keys(dataStore).forEach((key) => {\n\n    const value = urlParams.get(key);\n    if (value !== null) {\n      (dataStore as any)[key] = value;\n    }\n  });\n\n  dataStore.participantIdWasSet = urlParams.get('participantId') !== null;\n  dataStore.uploadNameWasSet = urlParams.get('uploadName') !== null;\n}\n","<template>\n  <UploadScreen />\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport UploadScreen from './components/UploadScreen.vue';\n\nexport default defineComponent({\n  name: 'App',\n  components: {\n    UploadScreen,\n  },\n});\n</script>\n\n<style lang=\"scss\">\n</style>\n","<template>\n  <section class=\"section\">\n    <div class=\"container\">\n      <h1 class=\"title\">Video Upload</h1>\n      <h2 class=\"subtitle\">{{dataStore.experimentName}}</h2>\n\n      <div class=\"field is-horizontal\">\n        <div class=\"field-label is-normal\">Participant Id</div>\n        <div class=\"field-body\">\n          <div class=\"field is-narrow\">\n            <div class=\"control\">\n              <input type=\"text\" class=\"input\"\n                :disabled=\"dataStore.participantIdWasSet\"\n                v-model=\"dataStore.participantId\">\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class=\"field is-horizontal\">\n        <div class=\"field-label is-normal\">Upload Identifier</div>\n        <div class=\"field-body\">\n          <div class=\"field is-narrow\">\n            <div class=\"control\">\n              <input type=\"text\" class=\"input\"\n                :disabled=\"dataStore.uploadNameWasSet\"\n                v-model=\"dataStore.uploadName\">\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <p><strong>Instructions:</strong> {{dataStore.prompt}}</p>\n\n      <div v-if=\"state === 'Record'\">\n        <WebcamBox />\n\n        <div class=\"field is-grouped is-grouped-centered\" v-show=\"webcamStatus === 'running'\">\n          <p class=\"control\">\n            <span class=\"record-icon\" :class=\"{'is-recording': isRecording}\">\n            </span>\n            <!-- <span class=\"icon is-medium\" :class=\"{'has-text-danger': isRecording}\">\n              <FAIcon icon=\"record-vinyl\" size=\"lg\" pulse />\n            </span> -->\n          </p>\n          <p class=\"control\">\n            <button class=\"button animate-width\"\n              @click=\"toggleRecording\">\n\n               <span v-show=\"isRecording\">\n                Stop\n              </span>\n              <span v-show=\"!isRecording\">\n                Record\n              </span>\n\n              <!-- <span v-if=\"!isRecording\">Start Recording</span> -->\n            </button>\n          </p>\n        </div>\n      </div>\n\n      <div v-if=\"state === 'Review'\">\n        <video class=\"flipped\" controls :src=\"recordedObjectUrl\"></video>\n\n        <div class=\"field is-grouped is-grouped-centered\">\n          <p class=\"control\">\n            <button class=\"button\" :disabled=\"isUploading\" @click=\"rerecord\">\n              Rerecord\n              <!-- <span class=\"icon is-medium\" :class=\"{'has-text-danger': isRecording}\">\n                <FAIcon icon=\"record-vinyl\" />\n              </span> -->\n              <!-- <span v-if=\"!isRecording\">Start Recording</span> -->\n            </button>\n          </p>\n          <p class=\"control\">\n            <button class=\"button is-primary\"\n              :disabled=\"isUploading\"\n              :class=\"{'is-loading': isUploading}\"\n              @click=\"uploadVideo\">\n              Upload Video\n            </button>\n          </p>\n        </div>\n\n        <div class=\"notification\" v-if=\"uploadError\">\n          {{uploadError}}\n        </div>\n\n      </div>\n\n    </div>\n  </section>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, ref } from 'vue';\nimport dataStore from '@/services/DataStore';\nimport webcamProvider from '@/services/WebcamProvider';\nimport AzureUploader from '@/services/AzureUploader';\n\nimport WebcamBox from './WebcamBox.vue';\n\nexport default defineComponent({\n  name: 'UploadScreen',\n  components: { WebcamBox },\n  setup() {\n\n    const state = ref('Record' as 'Record' | 'Review');\n\n    const lastRecordedBlob = ref(null as Blob | null);\n    const recordedObjectUrl = ref('');\n    const isUploading = ref(false);\n    const uploadError = ref(null as null | any);\n\n    return {\n      state,\n      dataStore,\n      webcamProvider,\n      webcamStatus: webcamProvider.webcamStatus,\n      isRecording: webcamProvider.isRecording,\n      lastRecordedBlob,\n      recordedObjectUrl,\n      isUploading,\n      uploadError,\n    };\n  },\n  methods: {\n    async toggleRecording() {\n      if (!webcamProvider.isRecording.value) {\n        await webcamProvider.startWebcam();\n        await webcamProvider.startRecording();\n      } else {\n        this.lastRecordedBlob = await webcamProvider.stopRecording();\n        this.recordedObjectUrl = URL.createObjectURL(this.lastRecordedBlob);\n        this.state = 'Review';\n        await webcamProvider.stopWebcam();\n      }\n    },\n    async rerecord() {\n      this.lastRecordedBlob = null;\n      this.recordedObjectUrl = '';\n      this.uploadError = null;\n      this.state = 'Record';\n      await webcamProvider.startWebcam();\n    },\n    async uploadVideo() {\n      if (!this.lastRecordedBlob) return;\n      if (this.isUploading) return;\n\n      this.isUploading = true;\n      this.uploadError = null;\n      const blobName = `${dataStore.experimentName}-${dataStore.participantId}-${dataStore.uploadName}.webm`;\n\n      try {\n        await AzureUploader.upload(this.lastRecordedBlob, blobName);\n      } catch (e) {\n        console.error('Error uploading video', e);\n        this.uploadError = e;\n      }\n\n      if (this.uploadError === null) {\n        this.uploadError = 'Upload Successful';\n      }\n\n      this.isUploading = false;\n    },\n  },\n});\n\n</script>\n\n<style lang=\"scss\">\n\n@import \"@/assets/main.scss\";\n\n.animate-width {\n  transition: width 0.2s ease;\n}\n\n.record-icon {\n  display: block;\n  width: 1.5rem;\n  height: 1.5rem;\n  border-radius: 1rem;\n  background-color: $dark;\n  transition: background-color 0.2s ease;\n\n  &.is-recording {\n    background-color: $red;\n  }\n}\n\n.control .record-icon {\n  margin-top: 8px;\n}\n</style>\n","import RecordRTC from 'recordrtc';\n\nimport { computed, ref, Ref } from 'vue';\n\nexport class WebcamProvider {\n\n  // Recorder class\n  private recorder = ref(null as null | RecordRTC);\n\n  // The actual media stream\n  private mediaStream = ref(null as null | MediaStream);\n\n  // List of active connections. Used so we know when to pause the webcam\n  private activeConnections: Set<HTMLVideoElement> = new Set();\n\n  private permissionState: Ref<PermissionState> = ref('prompt');\n\n  private isWebcamLoading = ref(false);\n\n  public webcamError = ref(null as any);\n\n  public isRecording = ref(false);\n\n  constructor() {\n    this.readPermissionStatus();\n  }\n\n  private async readPermissionStatus(): Promise<void> {\n    if (navigator.permissions) {\n      try {\n        const result = await navigator.permissions.query({ name: 'camera' });\n        this.permissionState.value = result.state;\n\n      // eslint-disable-next-line no-empty\n      } catch { }\n    }\n  }\n\n  public permissionStatus(): Ref<PermissionState> {\n    return this.permissionState;\n  }\n\n  public async startWebcam(): Promise<void> {\n    if (this.mediaStream.value || this.isWebcamLoading.value) {\n      return;\n    }\n    this.isWebcamLoading.value = true;\n\n    try {\n      const constraints: MediaStreamConstraints = {\n        video: {\n          facingMode: 'user',\n          width: 1280,\n          height: 720,\n          aspectRatio: 1.777777778,\n          frameRate: 30,\n        },\n        audio: true,\n      };\n\n      if (!navigator.mediaDevices?.getUserMedia) throw new Error(\"Browser doesn't support webcam\");\n\n      this.mediaStream.value = await navigator.mediaDevices.getUserMedia(constraints);\n\n      this.permissionState.value = 'granted';\n    } finally {\n      this.isWebcamLoading.value = false;\n    }\n  }\n\n  public webcamStatus = computed(() => {\n    if (this.mediaStream.value) return 'running';\n    if (this.isWebcamLoading.value) return 'loading';\n    return 'stopped';\n  });\n\n  public async connectVideoElement(videoE: HTMLVideoElement): Promise<void> {\n\n    if (this.permissionState.value !== 'granted') throw new Error(\"Doesn't have permissions yet!\");\n\n    this.activeConnections.add(videoE);\n\n    // eslint-disable-next-line no-param-reassign\n    console.log('Connecting media stream to video', this.mediaStream, videoE);\n    videoE.srcObject = this.mediaStream.value;\n    videoE.onloadedmetadata = () => {\n      videoE.play();\n    };\n  }\n\n  public disconnectVideoElement(videoE: HTMLVideoElement): void {\n    this.activeConnections.delete(videoE);\n\n    videoE.srcObject = null;\n\n    if (this.activeConnections.size === 0 && !this.recorder) {\n      this.stopWebcam();\n    }\n  }\n\n  public async stopWebcam(): Promise<void> {\n    if (this.recorder) {\n      try {\n        await this.stopRecording();\n      // eslint-disable-next-line no-empty\n      } catch { }\n    }\n\n    if (this.mediaStream.value) {\n      this.mediaStream.value.getTracks().forEach((x) => x.stop());\n    }\n    this.mediaStream.value = null;\n  }\n\n  public async startRecording(): Promise<void> {\n    if (this.recorder.value || this.isRecording.value) {\n      return;\n    }\n\n    if (!this.mediaStream.value) {\n      throw new Error('Webcam must be started before recording can happen');\n    }\n\n    this.isRecording.value = true;\n\n    const rtc = new RecordRTC(this.mediaStream.value, {\n      type: 'video',\n    });\n    rtc.startRecording();\n    this.recorder.value = rtc;\n  }\n\n  public async stopRecording(): Promise<Blob> {\n\n    return new Promise((res) => {\n      if (!this.recorder.value) throw new Error(\"Haven't started recording\");\n      this.isRecording.value = false;\n      const recorder = this.recorder.value;\n      this.recorder.value.stopRecording(() => {\n        res(recorder.getBlob());\n        this.recorder.value = null;\n      });\n    });\n  }\n\n  public async clearRecording(): Promise<void> {\n    // TODO: pay attention to status of recording\n    // this.recorder?.stopRecording();\n    this.recorder.value = null;\n  }\n\n  // public async postFiles(url: string, filename: string): Promise<void> {\n  //   if (!this.recorder) throw new Error('Nothing to post');\n\n  //   const blob = this.recorder.getBlob();\n  //   invokeSaveAsDialog(blob, filename);\n\n  //   const fname = `${filename}.webm`;\n\n  //   const file = new File([blob], fname, {\n  //     type: 'video/webm',\n  //   });\n\n  // videoElement.src = '';\n  // videoElement.srcObject = null;\n\n  // if (mediaStream) { mediaStream.stop(); }\n  // }\n}\n\nconst defaultProvider = new WebcamProvider();\n\nexport default defaultProvider;\n","// import { DefaultAzureCredential } from '@azure/identity';\nimport { BlobServiceClient } from '@azure/storage-blob';\n\n// const credential = new DefaultAzureCredential();\n\nconst blobServiceClient = new BlobServiceClient(\n  // 'https://dartrobotlabstorage.blob.core.windows.net/study-video-uploads?sp=acw&st=2021-04-07T02:19:35Z&se=2022-04-07T10:19:35Z&sv=2020-02-10&sr=c&sig=9fpKagbOjUqAjHF579%2FW7KiM4U8YcBrbI8J70tH35Y4%3D',\n  // credential,\n  'https://dartrobotlabstorage.blob.core.windows.net/study-video-uploads?sp=acw&st=2022-08-02T21:43:40Z&se=2024-08-03T05:43:40Z&spr=https&sv=2021-06-08&sr=c&sig=SwOP7nqXU21CAeFTS5UDD02uV72QSwuS2aGEdzdxZTc%3D',\n);\n\nexport default class AzureUploader {\n  public static async upload(data: Blob, blobName: string): Promise<void> {\n    const client = blobServiceClient.getContainerClient('standalone-video-uploads');\n\n    const blockBlobClient = client.getBlockBlobClient(blobName);\n\n    await blockBlobClient.uploadData(data);\n  }\n}\n","<template>\n  <div class=\"is-relative webcam-box\">\n    <video ref=\"videoE\" muted\n    ></video>\n    <div class=\"is-overlay\" v-if=\"webcamStatus !== 'running'\">\n      <div class=\"vcenter-parent\">\n        <div class=\"notification\" v-if=\"this.webcamStartError !== null\">\n          {{this.webcamStartError}}\n        </div>\n        <button\n          @click=\"startWebcam\"\n          class=\"button is-primary\"\n          v-show=\"webcamStatus !== 'running'\"\n          :class=\"{'is-loading': webcamStatus==='loading'}\">\n          Start Webcam\n        </button>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\n\nimport {\n  defineComponent, onBeforeUnmount, onMounted, ref, watch,\n} from 'vue';\n\nimport webcamProvider from '@/services/WebcamProvider';\n\nexport default defineComponent({\n  name: 'WebcamBox',\n  props: {\n    enableRecordButton: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup() {\n    // const enableRecordButton = toRefs(props);\n\n    const videoE = ref(null as null | HTMLVideoElement);\n    const webcamStartError = ref(null as null | any);\n\n    onMounted(() => {\n      if (!videoE.value) throw new Error('videoE is null');\n      if (webcamProvider.webcamStatus.value === 'running') {\n        webcamProvider.connectVideoElement(videoE.value);\n      }\n    });\n    watch(webcamProvider.webcamStatus, (status) => {\n      if (status === 'running' && videoE.value) {\n        webcamProvider.connectVideoElement(videoE.value);\n      }\n    });\n    onBeforeUnmount(() => {\n      if (!videoE.value) throw new Error('videoE is null');\n      webcamProvider.disconnectVideoElement(videoE.value);\n    });\n\n    return {\n      videoE,\n      webcamStartError,\n      webcamProvider,\n      webcamStatus: webcamProvider.webcamStatus,\n      isRecording: webcamProvider.isRecording,\n    };\n  },\n  methods: {\n    async startWebcam() {\n      this.webcamStartError = null;\n\n      try {\n        await webcamProvider.startWebcam();\n      } catch (e) {\n        this.webcamStartError = e;\n      }\n\n      if (!this.videoE) throw new Error('videoE is null');\n      await webcamProvider.connectVideoElement(this.videoE);\n    },\n    playVideo() {\n      if (!this.videoE) throw new Error('videoE is null');\n      this.videoE.play();\n    },\n  },\n});\n</script>\n\n<style lang=\"scss\">\n\n.webcam-box {\n\n  max-width: 100%;\n  max-height: 100%;\n\n  video {\n    background: rgba(128, 128, 128, 0.5);\n    width: 1280px;\n    // height: 720px;\n    max-height: 100%;\n    max-width: 100%;\n\n    transform: scaleX(-1);\n  }\n}\n</style>\n","\n\nimport {\n  defineComponent, onBeforeUnmount, onMounted, ref, watch,\n} from 'vue';\n\nimport webcamProvider from '@/services/WebcamProvider';\n\nexport default defineComponent({\n  name: 'WebcamBox',\n  props: {\n    enableRecordButton: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup() {\n    // const enableRecordButton = toRefs(props);\n\n    const videoE = ref(null as null | HTMLVideoElement);\n    const webcamStartError = ref(null as null | any);\n\n    onMounted(() => {\n      if (!videoE.value) throw new Error('videoE is null');\n      if (webcamProvider.webcamStatus.value === 'running') {\n        webcamProvider.connectVideoElement(videoE.value);\n      }\n    });\n    watch(webcamProvider.webcamStatus, (status) => {\n      if (status === 'running' && videoE.value) {\n        webcamProvider.connectVideoElement(videoE.value);\n      }\n    });\n    onBeforeUnmount(() => {\n      if (!videoE.value) throw new Error('videoE is null');\n      webcamProvider.disconnectVideoElement(videoE.value);\n    });\n\n    return {\n      videoE,\n      webcamStartError,\n      webcamProvider,\n      webcamStatus: webcamProvider.webcamStatus,\n      isRecording: webcamProvider.isRecording,\n    };\n  },\n  methods: {\n    async startWebcam() {\n      this.webcamStartError = null;\n\n      try {\n        await webcamProvider.startWebcam();\n      } catch (e) {\n        this.webcamStartError = e;\n      }\n\n      if (!this.videoE) throw new Error('videoE is null');\n      await webcamProvider.connectVideoElement(this.videoE);\n    },\n    playVideo() {\n      if (!this.videoE) throw new Error('videoE is null');\n      this.videoE.play();\n    },\n  },\n});\n","import { render } from \"./WebcamBox.vue?vue&type=template&id=b88bad26\"\nimport script from \"./WebcamBox.vue?vue&type=script&lang=ts\"\nexport * from \"./WebcamBox.vue?vue&type=script&lang=ts\"\n\nimport \"./WebcamBox.vue?vue&type=style&index=0&id=b88bad26&lang=scss\"\nscript.render = render\n\nexport default script","\nimport { defineComponent, ref } from 'vue';\nimport dataStore from '@/services/DataStore';\nimport webcamProvider from '@/services/WebcamProvider';\nimport AzureUploader from '@/services/AzureUploader';\n\nimport WebcamBox from './WebcamBox.vue';\n\nexport default defineComponent({\n  name: 'UploadScreen',\n  components: { WebcamBox },\n  setup() {\n\n    const state = ref('Record' as 'Record' | 'Review');\n\n    const lastRecordedBlob = ref(null as Blob | null);\n    const recordedObjectUrl = ref('');\n    const isUploading = ref(false);\n    const uploadError = ref(null as null | any);\n\n    return {\n      state,\n      dataStore,\n      webcamProvider,\n      webcamStatus: webcamProvider.webcamStatus,\n      isRecording: webcamProvider.isRecording,\n      lastRecordedBlob,\n      recordedObjectUrl,\n      isUploading,\n      uploadError,\n    };\n  },\n  methods: {\n    async toggleRecording() {\n      if (!webcamProvider.isRecording.value) {\n        await webcamProvider.startWebcam();\n        await webcamProvider.startRecording();\n      } else {\n        this.lastRecordedBlob = await webcamProvider.stopRecording();\n        this.recordedObjectUrl = URL.createObjectURL(this.lastRecordedBlob);\n        this.state = 'Review';\n        await webcamProvider.stopWebcam();\n      }\n    },\n    async rerecord() {\n      this.lastRecordedBlob = null;\n      this.recordedObjectUrl = '';\n      this.uploadError = null;\n      this.state = 'Record';\n      await webcamProvider.startWebcam();\n    },\n    async uploadVideo() {\n      if (!this.lastRecordedBlob) return;\n      if (this.isUploading) return;\n\n      this.isUploading = true;\n      this.uploadError = null;\n      const blobName = `${dataStore.experimentName}-${dataStore.participantId}-${dataStore.uploadName}.webm`;\n\n      try {\n        await AzureUploader.upload(this.lastRecordedBlob, blobName);\n      } catch (e) {\n        console.error('Error uploading video', e);\n        this.uploadError = e;\n      }\n\n      if (this.uploadError === null) {\n        this.uploadError = 'Upload Successful';\n      }\n\n      this.isUploading = false;\n    },\n  },\n});\n\n","import { render } from \"./UploadScreen.vue?vue&type=template&id=4c9ab232\"\nimport script from \"./UploadScreen.vue?vue&type=script&lang=ts\"\nexport * from \"./UploadScreen.vue?vue&type=script&lang=ts\"\n\nimport \"./UploadScreen.vue?vue&type=style&index=0&id=4c9ab232&lang=scss\"\nscript.render = render\n\nexport default script","\nimport { defineComponent } from 'vue';\nimport UploadScreen from './components/UploadScreen.vue';\n\nexport default defineComponent({\n  name: 'App',\n  components: {\n    UploadScreen,\n  },\n});\n","import { render } from \"./App.vue?vue&type=template&id=0bc37b64\"\nimport script from \"./App.vue?vue&type=script&lang=ts\"\nexport * from \"./App.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","/* eslint-disable no-console */\n\nimport { register } from 'register-service-worker';\n\nif (process.env.NODE_ENV === 'production') {\n  register(`${process.env.BASE_URL}service-worker.js`, {\n    ready() {\n      console.log(\n        'App is being served from cache by a service worker.\\n'\n        + 'For more details, visit https://goo.gl/AFskqB',\n      );\n    },\n    registered() {\n      console.log('Service worker has been registered.');\n    },\n    cached() {\n      console.log('Content has been cached for offline use.');\n    },\n    updatefound() {\n      console.log('New content is downloading.');\n    },\n    updated() {\n      console.log('New content is available; please refresh.');\n    },\n    offline() {\n      console.log('No internet connection found. App is running in offline mode.');\n    },\n    error(error) {\n      console.error('Error during service worker registration:', error);\n    },\n  });\n}\n","import { createApp, nextTick } from 'vue';\n\nimport { library } from '@fortawesome/fontawesome-svg-core';\nimport { faRecordVinyl } from '@fortawesome/free-solid-svg-icons';\nimport { FontAwesomeIcon } from '@fortawesome/vue-fontawesome';\n\nimport InterpretUrl from '@/services/UrlInterpreter';\n\nimport App from './App.vue';\nimport './registerServiceWorker';\n\n// https://www.npmjs.com/package/@fortawesome/vue-fontawesome\nlibrary.add(faRecordVinyl);\n\nrequire('@/assets/main.scss');\n\ncreateApp(App)\n  .component('FAIcon', FontAwesomeIcon)\n  .mount('#app');\n\nnextTick(InterpretUrl);\n"],"sourceRoot":""}